let Parser = import("./parser.rebo")

let _Int = { kind: "Constructor", name: "Int" }
let _Float = { kind: "Constructor", name: "Float" }

let _schemes() = {
   plus: 
   { kind: "Scheme"
   , params: [ { kind: "Or", types: [_Int, _Float] } ]
   , type: 
     { kind: "Function"
     , domain: 
       { kind: "Function"
       , domain: { kind: "Variable", offset: 0 }
       , range: { kind: "Variable", offset: 0 }
       }
     , range: { kind: "Variable", offset: 0 }
     }
   }
}

let newEnv() {
   let _scheme = _schemes()
   let _subst = {}
   let _constraints = []
   let _fresh = 0

   { 
      schemes: _scheme,          # schemes for declared values
      subst: _subst,             # type substitutions
      constraints: _constraints, # type constraints to be unified

      fresh: fn() {
         let fresh = _fresh
         _fresh := fresh + 1
         fresh
      },

      newSubstitution: fn(from, to) {
         _subst[str(from, false)] := to
      }
   }
}

let infer(text, env) {
   env := env ? newEnv()

   text
   |> Parser.using(Parser.expression)
   |> inferExpression(env)
}

let inferExpression(ast, env) =
   match ast
   | { kind: "LiteralFloat" } -> _Float
   | { kind: "LiteralInt" } -> _Int
   | { kind: "Identifier" } -> instantiate(env, env.schemes[ast.value] ? (raise "Unbound Identifier: " + ast.value))

let bindType(env, name, type) {
   env.schemes[name] := { kind: "Scheme", params: [], type: type }

   env
}

let instantiate(env, scheme) {
   scheme.params |> each(fn (param) {
      let fresh = { kind: "Variable", offset: env.fresh() }
      env.newSubstitution(param, fresh)
   })

   substitute(env, scheme.type)
}

let substitute(env, type) {
   match type
   | { kind: "Variable", offset } -> env.subst[offset] ? type
   | { kind: "Function", domain, range } -> { kind: "Function", domain: substitute(env, domain), range: substitute(env, range) }
   | { kind: "Or", types } -> { kind: "Or", types: types |> map(fn (type) { substitute(env, type) }) }
   | _ -> type
}
